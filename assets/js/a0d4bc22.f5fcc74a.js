"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2481],{4816:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"polls/Wall depth Poll","title":"Wall depth Poll","description":"Wall POI Depth Poll","source":"@site/docs/polls/Wall depth Poll.md","sourceDirName":"polls","slug":"/polls/Wall depth Poll","permalink":"/wotr-docs/docs/polls/Wall depth Poll","draft":false,"unlisted":false,"editUrl":"https://github.com/Wanderers-Of-The-Rift/wotr-docs/edit/main/website/docs/polls/Wall depth Poll.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Should we remove enchanting from the mod?","permalink":"/wotr-docs/docs/polls/enchanting"},"next":{"title":"Decorative & Building Block Mods","permalink":"/wotr-docs/docs/polls/Decorative & Building Block Mods Poll"}}');var s=l(4848),t=l(8453);const o={},r=void 0,a={},d=[{value:"Poll",id:"poll",level:2},{value:"Options",id:"options",level:2},{value:"Option 1",id:"option-1",level:3},{value:"Option 2",id:"option-2",level:3},{value:"Option 3",id:"option-3",level:3},{value:"Option 4",id:"option-4",level:3},{value:"Option 5",id:"option-5",level:3},{value:"Results",id:"results",level:2}];function h(e){const n={h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Wall POI Depth Poll"}),'\nWhen placing POIs against walls, we require a predefined depth -- a standard for how much they will "sink into" the wall. This is for the MVP so far, ',(0,s.jsx)(n.strong,{children:"more options can be picked/added later"}),", when we have made a solid amount and want more variation. As always, we'll determine this through a poll. Here are the options:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"On the wall"})," -- POI is attached to the wall, sinking just 1 block in to match the surroundings."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"In the wall"})," -- POI is fully embedded into the wall, creating a cave."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Halfway"})," -- POI is partially inside the wall, other half sticking out."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"See provided images for an overview, and examples for each. Note that this poll is NOT about the appearance of the POIs, ONLY about how deep we want them to be. They also have different sizes. There is also an example on the Build Server, have a look there to see the differences for yourself."}),"\n",(0,s.jsxs)(n.p,{children:["There are advantages and disadvantages to all options:\n",(0,s.jsx)(n.strong,{children:"On the wall"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pro: No thick walls required. Very visible from distance."}),"\n",(0,s.jsx)(n.li,{children:"Con: Somewhat similar to free-standing POIs. Takes up more floor space."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"In the wall"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pro: Saves floor space. Very distinct from other POI types."}),"\n",(0,s.jsx)(n.li,{children:"Con: Thick walls required, as POI depth must be fully covered."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Halfway"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pro: Distinct from other POIs. Versatile: can accommodate both On-wall POIs that don't demand full surface area, and In-wall POIs that are shallow. Less demanding on room building"}),"\n",(0,s.jsx)(n.li,{children:"Con: Not a champion in either: can't have deep caves or POIs sticking out far"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Thick walls and open floor areas limit building flexibility, hence are a real downside."}),"\n",(0,s.jsxs)(n.p,{children:["There is an option to pick multiple depths, however keep in mind that this essentially means ",(0,s.jsx)(n.strong,{children:"splitting"})," the available POI pool, requiring double the designs to be created.\nWe can always ",(0,s.jsxs)(n.strong,{children:["add ",(0,s.jsx)(n.strong,{children:"more depth levels pools"})," later on"]}),", if we are loaded with POIs. At this moment, we have far from enough for current pools, so adding more options hinders a lot."]}),"\n",(0,s.jsx)(n.h2,{id:"poll",children:"Poll"}),"\n",(0,s.jsx)(n.p,{children:"How much do we want the Wall POIs to sink into the wall?"}),"\n",(0,s.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,s.jsx)(n.h3,{id:"option-1",children:"Option 1"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"On the wall"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"option-2",children:"Option 2"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In the wall"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"option-3",children:"Option 3"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Halfway"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"option-4",children:"Option 4"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"On the wall & In the wall"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"option-5",children:"Option 5"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In the wall & Halfway"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"results",children:"Results"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"3%"}),"\n",(0,s.jsx)(n.li,{children:"3%"}),"\n",(0,s.jsx)(n.li,{children:"13%"}),"\n",(0,s.jsx)(n.li,{children:"40%"}),"\n",(0,s.jsx)(n.li,{children:"43%"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In the wall & Halfway won."})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>o,x:()=>r});var i=l(6540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);