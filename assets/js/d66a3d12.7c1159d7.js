"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8586],{67:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"code/api/configurable-hud","title":"Configurable HUD","description":"Wanderers of the Rift has a system for defining HUD elements whose rendering location can be configured, including the possibility of rotating for","source":"@site/docs/code/api/configurable-hud.md","sourceDirName":"code/api","slug":"/code/api/configurable-hud","permalink":"/wotr-docs/docs/code/api/configurable-hud","draft":false,"unlisted":false,"editUrl":"https://github.com/Wanderers-Of-The-Rift/wotr-docs/edit/main/website/docs/code/api/configurable-hud.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"API","permalink":"/wotr-docs/docs/code/api/"},"next":{"title":"QuickMover","permalink":"/wotr-docs/docs/code/api/quickmover"}}');var r=t(4848),a=t(8453);const o={},s="Configurable HUD",l={},d=[{value:"Principals",id:"principals",level:2},{value:"Configuration Info",id:"configuration-info",level:2},{value:"Usage",id:"usage",level:2},{value:"Adapting an existing HUD element",id:"adapting-an-existing-hud-element",level:3},{value:"Creating a native configurable HUD element",id:"creating-a-native-configurable-hud-element",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"configurable-hud",children:"Configurable HUD"})}),"\n",(0,r.jsx)(n.p,{children:"Wanderers of the Rift has a system for defining HUD elements whose rendering location can be configured, including the possibility of rotating for\ncompatible elements."}),"\n",(0,r.jsx)(n.h2,{id:"principals",children:"Principals"}),"\n",(0,r.jsxs)(n.p,{children:["A HUD element is rendered relative to a ",(0,r.jsx)(n.code,{children:"ScreenAnchor"}),". There are nine of these - one for each corner of the screen, one for the center of each\nside of the screen, and one for the center of the screen. Being anchored means that regardless of the screen size the element should moved to maintain the\nsame offset from that anchor. For example, when you resize the screen the hotbar remains attached to the bottom-center of the screen."]}),"\n",(0,r.jsx)(n.p,{children:"To achieve this the size of the HUD element needs to be known - its width and height. This allows the correct top-left position to be determined."}),"\n",(0,r.jsx)(n.p,{children:'For HUD elements that can grow or change sizes, this growth should ideally be "away" from the anchor. For example, when the player gains\nadditional hearts, they should appear in a new row above if anchored to the bottom of the screen, and a new row below if anchored to\nthe top of the screen.'}),"\n",(0,r.jsx)(n.h2,{id:"configuration-info",children:"Configuration Info"}),"\n",(0,r.jsx)(n.p,{children:"Each HUD element has the following configuration:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Whether the element is visible"}),"\n",(0,r.jsx)(n.li,{children:"Where the element is anchored"}),"\n",(0,r.jsx)(n.li,{children:"The x,y offset of the HUD element in pixels. This is applied relative to where the element is anchored."}),"\n",(0,r.jsx)(n.li,{children:"Optionally, the orientation of the element if rotation is supported."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.h3,{id:"adapting-an-existing-hud-element",children:"Adapting an existing HUD element"}),"\n",(0,r.jsx)(n.p,{children:"For use with vanilla or HUD elements from other mods."}),"\n",(0,r.jsxs)(n.p,{children:["In ClientConfig, add a ",(0,r.jsx)(n.code,{children:"HudElementConfig"})," for the HUD element - this will capture the player's configuration. Ensure the default values reflect\nhow the element is placed normally:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public static final HudElementConfig EXPERIENCE_BAR;\n\nstatic {\n    // For example, minecraft experience bar is displayed relative to the bottom-center of the screen\n    EXPERIENCE_BAR = new HudElementConfig.Builder("Vanilla Experience Bar", "xpBar")\n            .anchor(ScreenAnchor.BOTTOM_CENTER)\n            .offset(0, -24)\n            // If not specified, the element cannot be rotated\n            .rotates(UIOrientation.HORIZONTAL)\n            .build(builder);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Next register a ConfigurableLayerAdapter for the element - this will intercept the rendering of element and reposition (and optionally rotate) it based\non the configuration. A basic fixed size adapter is provided to handle basic HUD elements - this requires knowing the maximum width and height of the element.\nA separate DeferredRegister should be used for vanilla and each mod."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public static final DeferredRegister<ConfigurableLayer> VANILLA_LAYERS = DeferredRegister\n        .create(WotrClientRegistries.Keys.CONFIGURABLE_LAYERS, "minecraft");\n\npublic static final Supplier<ConfigurableLayerAdapter> VANILLA_XP_BAR = VANILLA_LAYERS.register(\n            VanillaGuiLayers.EXPERIENCE_BAR.getPath(),\n            () -> new FixedSizeLayerAdapter(Component.translatable("hud.minecraft.experience_bar"), ClientConfig.EXPERIENCE_BAR, 182, 5, List.of(VanillaGuiLayers.EXPERIENCE_BAR)));\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For more advanced handling a custom adapter can be created by implementing ",(0,r.jsx)(n.code,{children:"ConfigurableLayerAdapter"}),". This provides access to ",(0,r.jsx)(n.code,{children:"preRender"}),", ",(0,r.jsx)(n.code,{children:"render"}),", and ",(0,r.jsx)(n.code,{children:"postRender"})," for the layer.\nThis can be used to manipulate the poseStack to reposition and rotate the existing layer when it is rendered. Do take care to undo any transformations made in ",(0,r.jsx)(n.code,{children:"preRender"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-native-configurable-hud-element",children:"Creating a native configurable HUD element"}),"\n",(0,r.jsxs)(n.p,{children:["First, once more will need to add a ",(0,r.jsx)(n.code,{children:"HudElementConfig"})," for the new HUD element:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public static final HudElementConfig MANA_BAR;\n\nstatic {\nMANA_BAR = new HudElementConfig.Builder("Mana Bar", "manaBar").anchor(ScreenAnchor.TOP_LEFT)\n                .offset(25, 0)\n                // Optional, if rotates is not specified then the HUD element will not be rotatable\n                .rotates(UIOrientation.VERTICAL)\n                .build(builder);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The HUD element itself should implement ",(0,r.jsx)(n.code,{children:"ConfigurableLayer"})," - this requires implementing four methods. These are used primarily\nby the configuration UI."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class ManaBar implements ConfigurableLayer {\n    /**\n     * @return The name of the Layer (for display in tooltip)\n     */\n    public Component getName() {\n        return Component.translatable("hud.mymod.manabar");\n    }\n\n    /**\n     * @return The configuration that controls the layer\'s positioning\n     */\n    public HudElementConfig getConfig() {\n        return ClientConfig.MANA_BAR;\n    }\n\n    /**\n     * @return The width to display the element in the configuration screen. Ideally this is the display width of the\n     *         element, but may be representative of its potential width instead. Should not be zero. Should account\n     *         for rotation though.\n     */\n    public int getConfigWidth() {\n        return getConfig().getOrientation() == UIOrientation.VERTICAL ? 10 : 100;\n    }\n\n    /**\n     * @return The height to display the element in the configuration screen. Ideally this is the display height of the\n     *         element, but may be representative of its potential width instead. Should not be zero. Should account\n     *         for rotation though.\n     */\n    public int getConfigHeight() {\n        return getConfig().getOrientation() == UIOrientation.VERTICAL ? 100 : 10;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Beyond this, when rendering the element should use the config to determine where it should render:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Override\npublic void render(@NotNull GuiGraphics guiGraphics, @NotNull DeltaTracker deltaTracker) {\n    // General check for whether to render the element, including a getConfig().isVisible check.\n    Minecraft minecraft = Minecraft.getInstance();\n    if (minecraft.options.hideGui || !getConfig().isVisible() || minecraft.gameMode == null\n            || minecraft.gameMode.getPlayerMode() == GameType.SPECTATOR) {\n        return;\n    }\n    \n    // Determine the width and height of the element. This may need information about the player or state of the game\n    int width = calcWidth();\n    int height = calcHeight();\n    \n    // Top-left screen pos to render the element in\n    Vector2i pos = getConfig().getPosition(width, height, guiGraphics.guiWidth(), guiGraphics.guiHeight());\n    // Other config settings such as orientation can be used to determine how to render too.\n    UIOrientation orientation = getConfig().getOrientation();\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The HUD element should be registered as a configurable layer:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class ModConfigurableLayers {\n    public static final DeferredRegister<ConfigurableLayer> LAYERS = DeferredRegister\n            .create(WotrClientRegistries.Keys.CONFIGURABLE_LAYERS, Mod.MODID);\n\n    public static final Supplier<ConfigurableLayer> MANA_BAR = LAYERS.register("mana_bar", ManaBar::new);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"and should also be registered as a GuiLayer:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@EventBusSubscriber(modid = Mod.MODID, bus = EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)\npublic class ModGuiLayers {\n    public static final ResourceLocation MANA_BAR = ResourceLocation.fromNamespaceAndPath(Mod.MODID, "mana_bar");\n    \n    @SubscribeEvent\n    public static void registerGuiLayers(RegisterGuiLayersEvent event) {\n        event.registerAbove(VanillaGuiLayers.HOTBAR, MANA_BAR, ModConfigurableLayers.MANA_BAR.get());\n    }\n}\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(6540);const r={},a=i.createContext(r);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);